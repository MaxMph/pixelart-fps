[gd_scene load_steps=30 format=3 uid="uid://cdp0jw1lsgnbj"]

[ext_resource type="Texture2D" uid="uid://1q5gq1yuqgpq" path="res://cobblestone 1.png" id="1_50s0p"]
[ext_resource type="PackedScene" uid="uid://dg1keiig7fpso" path="res://player/player.tscn" id="1_eeid0"]
[ext_resource type="PackedScene" uid="uid://pigt1dxu8pg5" path="res://grass 1.tscn" id="3_r00ms"]
[ext_resource type="Texture2D" uid="uid://btsd5cql2gsvk" path="res://grass anim (try 1).png" id="13_1oeb5"]

[sub_resource type="ProceduralSkyMaterial" id="ProceduralSkyMaterial_odv1t"]
sky_top_color = Color(0, 0.373046, 0.394233, 1)
sky_horizon_color = Color(0.560018, 0.631379, 0.618472, 1)
ground_bottom_color = Color(0.240071, 0.15247, 0.0796567, 1)
ground_horizon_color = Color(0.560018, 0.631379, 0.618472, 1)

[sub_resource type="Sky" id="Sky_dv300"]
sky_material = SubResource("ProceduralSkyMaterial_odv1t")

[sub_resource type="Environment" id="Environment_h731i"]
background_mode = 2
sky = SubResource("Sky_dv300")
tonemap_mode = 2
glow_enabled = true

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_tjqdc"]
albedo_texture = ExtResource("1_50s0p")
uv1_scale = Vector3(4, 4, 4)
uv1_triplanar = true
texture_filter = 0

[sub_resource type="GDScript" id="GDScript_4h3ld"]
script/source = "@tool
extends Node3D


signal shape_changed
signal thread_completed
signal build_completed


# Includes
const ProtonScatterDomain := preload(\"./common/domain.gd\")
const ProtonScatterItem := preload(\"./scatter_item.gd\")
const ProtonScatterModifierStack := preload(\"./stack/modifier_stack.gd\")
const ProtonScatterPhysicsHelper := preload(\"./common/physics_helper.gd\")
const ProtonScatterShape := preload(\"./scatter_shape.gd\")
const ProtonScatterTransformList := preload(\"./common/transform_list.gd\")
const ProtonScatterUtil := preload('./common/scatter_util.gd')


@export_category(\"ProtonScatter\")

@export_group(\"General\")
@export var enabled := true:
	set(val):
		enabled = val
		if is_ready:
			rebuild()
@export var global_seed := 0:
	set(val):
		global_seed = val
		rebuild()
@export var show_output_in_tree := false:
	set(val):
		show_output_in_tree = val
		if output_root:
			ProtonScatterUtil.enforce_output_root_owner(self)

@export_group(\"Performance\")
@export_enum(\"Use Instancing:0\",
			\"Create Copies:1\",
			\"Use Particles:2\")\\
		var render_mode := 0:
	set(val):
		render_mode = val
		notify_property_list_changed()
		if is_ready:
			full_rebuild.call_deferred()

var use_chunks : bool = true:
	set(val):
		use_chunks = val
		notify_property_list_changed()
		if is_ready:
			full_rebuild.call_deferred()

var chunk_dimensions := Vector3.ONE * 15.0:
	set(val):
		chunk_dimensions.x = max(val.x, 1.0)
		chunk_dimensions.y = max(val.y, 1.0)
		chunk_dimensions.z = max(val.z, 1.0)
		if is_ready:
			rebuild.call_deferred()

@export var keep_static_colliders := false
@export var force_rebuild_on_load := true
@export var enable_updates_in_game := false

@export_group(\"Dependency\")
@export var scatter_parent: NodePath:
	set(val):
		if not is_inside_tree():
			scatter_parent = val
			return

		scatter_parent = NodePath()
		if is_instance_valid(_dependency_parent):
			_dependency_parent.build_completed.disconnect(rebuild)
			_dependency_parent = null

		var node = get_node_or_null(val)
		if not node:
			return

		var type = node.get_script()
		var scatter_type = get_script()
		if type != scatter_type:
			push_warning(\"ProtonScatter warning: Please select a ProtonScatter node as a parent dependency.\")
			return

		# TODO: Check for cyclic dependency

		scatter_parent = val
		_dependency_parent = node
		_dependency_parent.build_completed.connect(rebuild, CONNECT_DEFERRED)


@export_group(\"Debug\", \"dbg_\")
@export var dbg_disable_thread := false

var undo_redo # EditorUndoRedoManager - Can't type this, class not available outside the editor
var modifier_stack: ProtonScatterModifierStack:
	set(val):
		if modifier_stack:
			if modifier_stack.value_changed.is_connected(rebuild):
				modifier_stack.value_changed.disconnect(rebuild)
			if modifier_stack.stack_changed.is_connected(rebuild):
				modifier_stack.stack_changed.disconnect(rebuild)
			if modifier_stack.transforms_ready.is_connected(_on_transforms_ready):
				modifier_stack.transforms_ready.disconnect(_on_transforms_ready)

		modifier_stack = val.get_copy() # Enfore uniqueness
		modifier_stack.value_changed.connect(rebuild, CONNECT_DEFERRED)
		modifier_stack.stack_changed.connect(rebuild, CONNECT_DEFERRED)
		modifier_stack.transforms_ready.connect(_on_transforms_ready, CONNECT_DEFERRED)

var domain: ProtonScatterDomain:
	set(_val):
		domain = ProtonScatterDomain.new() # Enforce uniqueness

var items: Array = []
var total_item_proportion: int
var output_root: Marker3D
var transforms: ProtonScatterTransformList
var editor_plugin # Holds a reference to the EditorPlugin. Used by other parts.
var is_ready := false
var build_version := 0

# Internal variables
var _thread: Thread
var _rebuild_queued := false
var _dependency_parent
var _physics_helper: ProtonScatterPhysicsHelper
var _body_rid: RID
var _collision_shapes: Array[RID]
var _ignore_transform_notification = false


func _ready() -> void:
	if Engine.is_editor_hint() or enable_updates_in_game:
		set_notify_transform(true)
		child_exiting_tree.connect(_on_child_exiting_tree)

	_perform_sanity_check()
	_discover_items()
	update_configuration_warnings.call_deferred()
	is_ready = true

	if force_rebuild_on_load and not is_instance_valid(_dependency_parent):
		full_rebuild.call_deferred()


func _exit_tree():
	if is_thread_running():
		modifier_stack.stop_update()
		_thread.wait_to_finish()
		_thread = null
	
	_clear_collision_data()


func _get_property_list() -> Array:
	var list := []
	list.push_back({
		name = \"modifier_stack\",
		type = TYPE_OBJECT,
		hint_string = \"ScatterModifierStack\",
	})

	var chunk_usage := PROPERTY_USAGE_NO_EDITOR
	var dimensions_usage := PROPERTY_USAGE_NO_EDITOR
	if render_mode == 0 or render_mode == 2:
		chunk_usage = PROPERTY_USAGE_DEFAULT
		if use_chunks:
			dimensions_usage = PROPERTY_USAGE_DEFAULT

	list.push_back({
		name = \"Performance/use_chunks\",
		type = TYPE_BOOL,
		usage = chunk_usage
	})

	list.push_back({
		name = \"Performance/chunk_dimensions\",
		type = TYPE_VECTOR3,
		usage = dimensions_usage
	})
	return list


func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()

	if items.is_empty():
		warnings.push_back(\"At least one ScatterItem node is required.\")

	if modifier_stack and not modifier_stack.does_not_require_shapes():
		if domain and domain.is_empty():
			warnings.push_back(\"At least one ScatterShape node is required.\")

	return warnings


func _notification(what):
	if not is_ready:
		return
	match what:
		NOTIFICATION_TRANSFORM_CHANGED:
			if _ignore_transform_notification:
				_ignore_transform_notification = false
				return
			_perform_sanity_check()
			domain.compute_bounds()
			rebuild.call_deferred()
		NOTIFICATION_ENTER_WORLD:
			_ignore_transform_notification = true


func _set(property, value):
	if not Engine.is_editor_hint():
		return false

	# Workaround to detect when the node was duplicated from the editor.
	if property == \"transform\":
		_on_node_duplicated.call_deferred()

	elif property == \"Performance/use_chunks\":
		use_chunks = value

	elif property == \"Performance/chunk_dimensions\":
		chunk_dimensions = value

	# Backward compatibility.
	# Convert the value of previous property \"use_instancing\" into the proper render_mode.
	elif property == \"use_instancing\":
		render_mode = 0 if value else 1
		return true

	return false


func _get(property):
	if property == \"Performance/use_chunks\":
		return use_chunks

	elif property == \"Performance/chunk_dimensions\":
		return chunk_dimensions


func is_thread_running() -> bool:
	return _thread != null and _thread.is_started()


# Used by some modifiers to retrieve a physics helper node
func get_physics_helper() -> ProtonScatterPhysicsHelper:
	return _physics_helper


# Deletes what the Scatter node generated.
func clear_output() -> void:
	if not output_root:
		output_root = get_node_or_null(\"ScatterOutput\")

	if output_root:
		remove_child(output_root)
		output_root.queue_free()
		output_root = null

	ProtonScatterUtil.ensure_output_root_exists(self)
	_clear_collision_data()


func _clear_collision_data() -> void:
	if _body_rid.is_valid():
		PhysicsServer3D.free_rid(_body_rid)
		_body_rid = RID()

	for rid in _collision_shapes:
		if rid.is_valid():
			PhysicsServer3D.free_rid(rid)

	_collision_shapes.clear()


# Wrapper around the _rebuild function. Clears previous output and force
# a clean rebuild.
func full_rebuild():
	update_gizmos()

	if not is_inside_tree():
		return

	_rebuild_queued = false

	if is_thread_running():
		await _thread.wait_to_finish()
		_thread = null
	
	clear_output()
	_rebuild(true)


# A wrapper around the _rebuild function. Ensure it's not called more than once
# per frame. (Happens when the Scatter node is moved, which triggers the
# TRANSFORM_CHANGED notification in every children, which in turn notify the
# parent Scatter node back about the changes).
func rebuild(force_discover := false) -> void:
	update_gizmos()

	if not is_inside_tree() or not is_ready:
		return

	if is_thread_running():
		_rebuild_queued = true
		return

	force_discover = true # TMP while we fix the other issues
	_rebuild(force_discover)


# Re compute the desired output.
# This is the main function, scattering the objects in the scene.
# Scattered objects are stored under a Marker3D node called \"ScatterOutput\"
# DON'T call this function directly outside of the 'rebuild()' function above.
func _rebuild(force_discover) -> void:
	if not enabled:
		_clear_collision_data()
		clear_output()
		build_completed.emit()
		return

	_perform_sanity_check()

	if force_discover:
		_discover_items()
		domain.discover_shapes(self)

	if items.is_empty() or (domain.is_empty() and not modifier_stack.does_not_require_shapes()):
		clear_output()
		push_warning(\"ProtonScatter warning: No items or shapes, abort\")
		return

	if render_mode == 1:
		clear_output() # TMP, prevents raycasts in modifier to self intersect with previous output

	if keep_static_colliders:
		_clear_collision_data()

	if dbg_disable_thread:
		modifier_stack.start_update(self, domain)
		return

	if is_thread_running():
		await _thread.wait_to_finish()

	_thread = Thread.new()
	_thread.start(_rebuild_threaded, Thread.PRIORITY_NORMAL)


func _rebuild_threaded() -> void:
	# Disable thread safety, but only after 4.1 beta 3
	if _thread.has_method(\"set_thread_safety_checks_enabled\"):
		# Calls static method on instance, otherwise it crashes in 4.0.x
		@warning_ignore(\"static_called_on_instance\")
		_thread.set_thread_safety_checks_enabled(false)

	modifier_stack.start_update(self, domain.get_copy())


func _discover_items() -> void:
	items.clear()
	total_item_proportion = 0

	for c in get_children():
		if is_instance_of(c, ProtonScatterItem):
			items.push_back(c)
			total_item_proportion += c.proportion

	update_configuration_warnings()


# Creates one MultimeshInstance3D for each ScatterItem node.
func _update_multimeshes() -> void:
	if items.is_empty():
		_discover_items()

	var offset := 0
	var transforms_count: int = transforms.size()

	for item in items:
		var count = int(round(float(item.proportion) / total_item_proportion * transforms_count))
		var mmi = ProtonScatterUtil.get_or_create_multimesh(item, count)
		if not mmi:
			continue
		var static_body := ProtonScatterUtil.get_collision_data(item)

		var t: Transform3D
		for i in count:
			# Extra check because of how 'count' is calculated
			if (offset + i) >= transforms_count:
				mmi.multimesh.instance_count = i - 1
				continue

			t = item.process_transform(transforms.list[offset + i])
			mmi.multimesh.set_instance_transform(i, t)
			_create_collision(static_body, t)

		static_body.queue_free()
		offset += count


func _update_split_multimeshes() -> void:
	var size = domain.bounds_local.size

	var splits := Vector3i.ONE
	splits.x = max(1, ceil(size.x / chunk_dimensions.x))
	splits.y = max(1, ceil(size.y / chunk_dimensions.y))
	splits.z = max(1, ceil(size.z / chunk_dimensions.z))

	if items.is_empty():
		_discover_items()

	var offset := 0 # this many transforms have been used up
	var transforms_count: int = transforms.size()
	clear_output()

	for item in items:
		var root: Node3D = ProtonScatterUtil.get_or_create_item_root(item)
		if not is_instance_valid(root):
			continue
		
		# use count number of transforms for this item
		var count = int(round(float(item.proportion) / total_item_proportion * transforms_count))

		# create 3d array with dimensions of split_size to store the chunks' transforms
		var transform_chunks : Array = []
		for xi in splits.x:
			transform_chunks.append([])
			for yi in splits.y:
				transform_chunks[xi].append([])
				for zi in splits.z:
					transform_chunks[xi][yi].append([])

		var t_list = transforms.list.slice(offset)
		var aabb = ProtonScatterUtil.get_aabb_from_transforms(t_list)
		aabb = aabb.grow(0.1) # avoid degenerate cases
		var static_body := ProtonScatterUtil.get_collision_data(item)

		for i in count:
			if (offset + i) >= transforms_count:
				continue
			# both aabb and t are in mmi's local coordinates
			var t = item.process_transform(transforms.list[offset + i])
			var p_rel = (t.origin - aabb.position) / aabb.size
			# Chunk index
			var ci = (p_rel * Vector3(splits)).floor()
			# Store the transform to the appropriate array
			transform_chunks[ci.x][ci.y][ci.z].append(t)
			_create_collision(static_body, t)

		static_body.queue_free()

		# Cache the mesh instance to be used for the chunks
		var mesh_instance: MeshInstance3D = ProtonScatterUtil.get_merged_meshes_from(item)
		# The relevant transforms are now ordered in chunks
		for xi in splits.x:
			for yi in splits.y:
				for zi in splits.z:
					var chunk_elements = transform_chunks[xi][yi][zi].size()
					if chunk_elements == 0:
						continue
					var mmi = ProtonScatterUtil.get_or_create_multimesh_chunk(
													item, 
													mesh_instance, 
													Vector3i(xi, yi, zi), 
													chunk_elements)
					if not mmi:
						continue

					# Use the eventual aabb as origin
					# The multimeshinstance needs to be centered where the transforms are
					# This matters because otherwise the visibility range fading is messed up
					var center =  ProtonScatterUtil.get_aabb_from_transforms(transform_chunks[xi][yi][zi]).get_center()
					mmi.transform.origin = center

					var t: Transform3D
					for i in chunk_elements:
						t = transform_chunks[xi][yi][zi][i]
						t.origin -= center
						mmi.multimesh.set_instance_transform(i, t)
		mesh_instance.queue_free()
		offset += count


func _update_duplicates() -> void:
	var offset := 0
	var transforms_count: int = transforms.size()

	for item in items:
		var count := int(round(float(item.proportion) / total_item_proportion * transforms_count))
		var root: Node3D = ProtonScatterUtil.get_or_create_item_root(item)
		var child_count := root.get_child_count()

		for i in count:
			if (offset + i) >= transforms_count:
				return

			var instance
			if i < child_count: # Grab an instance from the pool if there's one available
				instance = root.get_child(i)
			else:
				instance = _create_instance(item, root)

			if not instance:
				break

			var t: Transform3D = item.process_transform(transforms.list[offset + i])
			instance.transform = t
			ProtonScatterUtil.set_visibility_layers(instance, item.visibility_layers)

		# Delete the unused instances left in the pool if any
		if count < child_count:
			for i in (child_count - count):
				root.get_child(-1).queue_free()

		offset += count


func _update_particles_system() -> void:
	var offset := 0
	var transforms_count: int = transforms.size()

	for item in items:
		var count := int(round(float(item.proportion) / total_item_proportion * transforms_count))
		var particles = ProtonScatterUtil.get_or_create_particles(item)
		if not particles:
			continue

		particles.visibility_aabb = AABB(domain.bounds_local.min, domain.bounds_local.size)
		particles.amount = count

		var static_body := ProtonScatterUtil.get_collision_data(item)
		var t: Transform3D

		for i in count:
			if (offset + i) >= transforms_count:
				particles.amount = i - 1
				return

			t = item.process_transform(transforms.list[offset + i])
			particles.emit_particle(
				t,
				Vector3.ZERO,
				Color.WHITE,
				Color.BLACK,
				GPUParticles3D.EMIT_FLAG_POSITION | GPUParticles3D.EMIT_FLAG_ROTATION_SCALE)
			_create_collision(static_body, t)

		offset += count


# Creates collision data with the Physics server directly.
# This does not create new nodes in the scene tree. This also means you can't
# see these colliders, even when enabling \"Debug > Visible collision shapes\".
func _create_collision(body: StaticBody3D, t: Transform3D) -> void:
	if not keep_static_colliders or render_mode == 1:
		return

	# Create a static body
	if not _body_rid.is_valid():
		_body_rid = PhysicsServer3D.body_create()
		PhysicsServer3D.body_set_mode(_body_rid, PhysicsServer3D.BODY_MODE_STATIC)
		PhysicsServer3D.body_set_state(_body_rid, PhysicsServer3D.BODY_STATE_TRANSFORM, global_transform)
		PhysicsServer3D.body_set_space(_body_rid, get_world_3d().space)

	for c in body.get_children():
		if c is CollisionShape3D:
			var shape_rid: RID
			var data: Variant

			if c.shape is SphereShape3D:
				shape_rid = PhysicsServer3D.sphere_shape_create()
				data = c.shape.radius

			elif c.shape is BoxShape3D:
				shape_rid = PhysicsServer3D.box_shape_create()
				data = c.shape.size / 2.0

			elif c.shape is CapsuleShape3D:
				shape_rid = PhysicsServer3D.capsule_shape_create()
				data = {
					\"radius\": c.shape.radius,
					\"height\": c.shape.height,
				}

			elif c.shape is CylinderShape3D:
				shape_rid = PhysicsServer3D.cylinder_shape_create()
				data = {
					\"radius\": c.shape.radius,
					\"height\": c.shape.height,
				}

			elif c.shape is ConcavePolygonShape3D:
				shape_rid = PhysicsServer3D.concave_polygon_shape_create()
				data = {
					\"faces\": c.shape.get_faces(),
					\"backface_collision\": c.shape.backface_collision,
				}

			elif c.shape is ConvexPolygonShape3D:
				shape_rid = PhysicsServer3D.convex_polygon_shape_create()
				data = c.shape.points

			elif c.shape is HeightMapShape3D:
				shape_rid = PhysicsServer3D.heightmap_shape_create()
				var min_height := 9999999.0
				var max_height := -9999999.0
				for v in c.shape.map_data:
					min_height = v if v < min_height else min_height
					max_height = v if v > max_height else max_height
				data = {
					\"width\": c.shape.map_width,
					\"depth\": c.shape.map_depth,
					\"heights\": c.shape.map_data,
					\"min_height\": min_height,
					\"max_height\": max_height,
				}

			elif c.shape is SeparationRayShape3D:
				shape_rid = PhysicsServer3D.separation_ray_shape_create()
				data = {
					\"length\": c.shape.length,
					\"slide_on_slope\": c.shape.slide_on_slope,
				}

			else:
				print_debug(\"Scatter - Unsupported collision shape: \", c.shape)
				continue

			PhysicsServer3D.shape_set_data(shape_rid, data)
			PhysicsServer3D.body_add_shape(_body_rid, shape_rid, t * c.transform)
			_collision_shapes.push_back(shape_rid)


func _create_instance(item: ProtonScatterItem, root: Node3D):
	if not item:
		return null

	var instance = item.get_item()
	if not instance:
		return null

	instance.visible = true
	root.add_child.bind(instance, true).call_deferred()

	if show_output_in_tree:
		# We have to use a lambda here because ProtonScatterUtil isn't an
		# actual class_name, it's a const, which makes it impossible to reference
		# the callable, (but we can still call it)
		var defer_ownership := func(i, o):
			ProtonScatterUtil.set_owner_recursive(i, o)
		defer_ownership.bind(instance, get_tree().get_edited_scene_root()).call_deferred()

	return instance


# Enforce the Scatter node has its required variables set.
func _perform_sanity_check() -> void:
	if not modifier_stack:
		modifier_stack = ProtonScatterModifierStack.new()
		modifier_stack.just_created = true

	if not domain:
		domain = ProtonScatterDomain.new()

	domain.discover_shapes(self)

	if not is_instance_valid(_physics_helper):
		_physics_helper = ProtonScatterPhysicsHelper.new()
		_physics_helper.name = \"PhysicsHelper\"
		add_child(_physics_helper, true, INTERNAL_MODE_BACK)

	# Retrigger the parent setter, in case the parent node no longer exists or changed type.
	scatter_parent = scatter_parent


# Remove output coming from the source node to avoid linked multimeshes or
# other unwanted side effects
func _on_node_duplicated() -> void:
	clear_output()


func _on_child_exiting_tree(node: Node) -> void:
	if node is ProtonScatterShape or node is ProtonScatterItem:
		rebuild.bind(true).call_deferred()


# Called when the modifier stack is done generating the full transform list
func _on_transforms_ready(new_transforms: ProtonScatterTransformList) -> void:
	if is_thread_running():
		await _thread.wait_to_finish()
		_thread = null

	_clear_collision_data()

	if _rebuild_queued:
		_rebuild_queued = false
		rebuild.call_deferred()
		return

	transforms = new_transforms

	if not transforms or transforms.is_empty():
		clear_output()
		update_gizmos()
		return

	match render_mode:
		0:
			if use_chunks:
				_update_split_multimeshes()
			else:
				_update_multimeshes()
		1:
			_update_duplicates()
		2:
			_update_particles_system()

	update_gizmos()
	build_version += 1
	
	if is_inside_tree():
		await get_tree().process_frame

	build_completed.emit()
"

[sub_resource type="GDScript" id="GDScript_u21fa"]
script/source = "@tool
extends Resource


signal stack_changed
signal value_changed
signal transforms_ready


const ProtonScatter := preload(\"../scatter.gd\")
const TransformList := preload(\"../common/transform_list.gd\")
const BaseModifier := preload(\"../modifiers/base_modifier.gd\")


@export var stack: Array[BaseModifier] = []

var just_created := false


func start_update(scatter_node: ProtonScatter, domain):
	var transforms = TransformList.new()

	for modifier in stack:
		await modifier.process_transforms(transforms, domain, scatter_node.global_seed)

	transforms_ready.emit(transforms)
	return transforms


func stop_update() -> void:
	for modifier in stack:
		modifier.interrupt()


func add(modifier: BaseModifier) -> void:
	stack.push_back(modifier)
	modifier.modifier_changed.connect(_on_modifier_changed)
	stack_changed.emit()


func move(old_index: int, new_index: int) -> void:
	var modifier = stack.pop_at(old_index)
	stack.insert(new_index, modifier)
	stack_changed.emit()


func remove(modifier: BaseModifier) -> void:
	if stack.has(modifier):
		stack.erase(modifier)
		stack_changed.emit()


func remove_at(index: int) -> void:
	if stack.size() > index:
		stack.remove_at(index)
		stack_changed.emit()


func duplicate_modifier(modifier: BaseModifier) -> void:
	var index: int = stack.find(modifier)
	if index != -1:
		var copy = modifier.get_copy()
		add(copy)
		move(stack.size() - 1, index + 1)


func get_copy():
	var copy = get_script().new()
	for modifier in stack:
		copy.add(modifier.duplicate())
	return copy


func get_index(modifier: BaseModifier) -> int:
	return stack.find(modifier)


func is_using_edge_data() -> bool:
	for modifier in stack:
		if modifier.use_edge_data:
			return true

	return false


# Returns true if at least one modifier does not require shapes in order to work.
# (This is the case for the \"Add single item\" modifier for example)
func does_not_require_shapes() -> bool:
	for modifier in stack:
		if modifier.warning_ignore_no_shape:
			return true

	return false


func _on_modifier_changed() -> void:
	stack_changed.emit()
"

[sub_resource type="GDScript" id="GDScript_6rtv1"]
script/source = "@tool
extends \"base_modifier.gd\"


@export var amount := 10

var _rng: RandomNumberGenerator


func _init() -> void:
	display_name = \"Create Inside (Random)\"
	category = \"Create\"
	warning_ignore_no_transforms = true
	warning_ignore_no_shape = false
	can_override_seed = true
	global_reference_frame_available = true
	local_reference_frame_available = true
	use_local_space_by_default()

	documentation.add_paragraph(
		\"Randomly place new transforms inside the area defined by
		the ScatterShape nodes.\")

	var p := documentation.add_parameter(\"Amount\")
	p.set_type(\"int\")
	p.set_description(\"How many transforms will be created.\")
	p.set_cost(2)

	documentation.add_warning(
		\"In some cases, the amount of transforms created by this modifier
		might be lower than the requested amount (but never higher). This may
		happen if the provided ScatterShape has a huge bounding box but a tiny
		valid space, like a curved and narrow path.\")


# TODO:
# + Multithreading
# + Spatial partionning to discard areas outside the domain earlier
func _process_transforms(transforms, domain, random_seed) -> void:
	_rng = RandomNumberGenerator.new()
	_rng.set_seed(random_seed)

	var gt: Transform3D = domain.get_global_transform()
	var center: Vector3 = domain.bounds_local.center
	var half_size: Vector3 = domain.bounds_local.size / 2.0
	var height: float = domain.bounds_local.center.y

	# Generate a random point in the bounding box. Store if it's inside the
	# domain, or discard if invalid. Repeat until enough valid points are found.
	var t: Transform3D
	var pos: Vector3
	var new_transforms: Array[Transform3D] = []
	var max_retries = amount * 10 # TODO: expose this parameter?
	var tries := 0

	while new_transforms.size() != amount:
		t = Transform3D()
		pos = _random_vec3() * half_size + center

		if restrict_height:
			pos.y = height

		if is_using_global_space():
			t.basis = gt.affine_inverse().basis

		if domain.is_point_inside(pos):
			t.origin = pos
			new_transforms.push_back(t)
			continue

		# Prevents an infinite loop
		tries += 1
		if tries > max_retries:
			break

	transforms.append(new_transforms)


func _random_vec3() -> Vector3:
	var vec3 = Vector3.ZERO
	vec3.x = _rng.randf_range(-1.0, 1.0)
	vec3.y = _rng.randf_range(-1.0, 1.0)
	vec3.z = _rng.randf_range(-1.0, 1.0)
	return vec3
"

[sub_resource type="Resource" id="Resource_670bh"]
script = SubResource("GDScript_6rtv1")
amount = 75
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = true
reference_frame = 1

[sub_resource type="GDScript" id="GDScript_p72nw"]
script/source = "@tool
extends \"base_modifier.gd\"


@export var position := Vector3.ZERO
@export var rotation := Vector3.ZERO
@export var scale := Vector3.ZERO

var _rng: RandomNumberGenerator


func _init() -> void:
	display_name = \"Randomize Transforms\"
	category = \"Edit\"
	can_override_seed = true
	can_restrict_height = false
	global_reference_frame_available = true
	local_reference_frame_available = true
	individual_instances_reference_frame_available = true
	use_individual_instances_space_by_default()


func _process_transforms(transforms, domain, random_seed) -> void:
	_rng = RandomNumberGenerator.new()
	_rng.set_seed(random_seed)

	var t: Transform3D
	var global_t: Transform3D
	var basis: Basis
	var random_scale: Vector3
	var random_position: Vector3
	var s_gt: Transform3D = domain.get_global_transform()
	var s_gt_inverse := s_gt.affine_inverse()

	# Global rotation axis
	var axis_x := Vector3.RIGHT
	var axis_y := Vector3.UP
	var axis_z := Vector3.DOWN

	if is_using_global_space():
		axis_x = (s_gt_inverse.basis * Vector3.RIGHT).normalized()
		axis_y = (s_gt_inverse.basis * Vector3.UP).normalized()
		axis_z = (s_gt_inverse.basis * Vector3.FORWARD).normalized()

	for i in transforms.size():
		t = transforms.list[i]
		basis = t.basis

		# Apply rotation
		if is_using_individual_instances_space():
			axis_x = basis.x.normalized()
			axis_y = basis.y.normalized()
			axis_z = basis.z.normalized()

		basis = basis.rotated(axis_x, deg_to_rad(_random_float() * rotation.x))
		basis = basis.rotated(axis_y, deg_to_rad(_random_float() * rotation.y))
		basis = basis.rotated(axis_z, deg_to_rad(_random_float() * rotation.z))

		# Apply scale
		random_scale = Vector3.ONE + (_rng.randf() * scale)

		if is_using_individual_instances_space():
			basis.x *= random_scale.x
			basis.y *= random_scale.y
			basis.z *= random_scale.z

		elif is_using_global_space():
			global_t = s_gt * Transform3D(basis, Vector3.ZERO)
			global_t = global_t.scaled(random_scale)
			basis = (s_gt_inverse * global_t).basis

		else:
			basis = basis.scaled(random_scale)

		# Apply position
		random_position = _random_vec3() * position

		if is_using_individual_instances_space():
			random_position = t.basis * random_position

		elif is_using_global_space():
			random_position = s_gt_inverse.basis * random_position

		t.origin += random_position
		t.basis = basis

		transforms.list[i] = t


func _random_vec3() -> Vector3:
	var vec3 = Vector3.ZERO
	vec3.x = _rng.randf_range(-1.0, 1.0)
	vec3.y = _rng.randf_range(-1.0, 1.0)
	vec3.z = _rng.randf_range(-1.0, 1.0)
	return vec3


func _random_float() -> float:
	return _rng.randf_range(-1.0, 1.0)


func _clamp_vector(vec3, vmin, vmax) -> Vector3:
	vec3.x = clamp(vec3.x, vmin.x, vmax.x)
	vec3.y = clamp(vec3.y, vmin.y, vmax.y)
	vec3.z = clamp(vec3.z, vmin.z, vmax.z)
	return vec3
"

[sub_resource type="Resource" id="Resource_o83yb"]
script = SubResource("GDScript_p72nw")
position = Vector3(0.15, 0.15, 0.15)
rotation = Vector3(15, 90, 15)
scale = Vector3(0.1, 0.1, 0.1)
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = false
reference_frame = 2

[sub_resource type="GDScript" id="GDScript_j3blm"]
script/source = "@tool
extends \"base_modifier.gd\"


const shader_file := preload(\"./compute_shaders/compute_relax.glsl\")


@export var iterations : int = 3
@export var offset_step : float = 0.01
@export var consecutive_step_multiplier : float = 0.5
@export var use_computeshader : bool = true


func _init() -> void:
	display_name = \"Relax Position\"
	category = \"Edit\"
	global_reference_frame_available = false
	local_reference_frame_available = false
	individual_instances_reference_frame_available = false
	can_restrict_height = true
	restrict_height = true

	documentation.add_warning(
		\"This modifier is has an O(n²) complexity and will be slow with
		large amounts of points, unless your device supports compute shaders.\",
		1)

	var p := documentation.add_parameter(\"iterations\")
	p.set_type(\"int\")
	p.set_cost(2)
	p.set_description(
		\"How many times the relax algorithm will run. Increasing this value will
		generally improves the result, at the cost of execution speed.\"
		)

	p = documentation.add_parameter(\"Offset step\")
	p.set_type(\"float\")
	p.set_cost(0)
	p.set_description(\"How far the transform will be pushed away each iteration.\")

	p = documentation.add_parameter(\"Consecutive step multiplier\")
	p.set_type(\"float\")
	p.set_cost(0)
	p.set_description(
		\"On each iteration, multiply the offset step by this value. This value
		is usually set between 0 and 1, to make the effect less pronounced on
		successive iterations.\")

	p = documentation.add_parameter(\"Use compute shader\")
	p.set_cost(0)
	p.set_type(\"bool\")
	p.set_description(
		\"Run the calculations on the GPU instead of the CPU. This provides
		a significant speed boost and should be enabled when possible.\")
	p.add_warning(
		\"This parameter can't be enabled when using the OpenGL backend or running
		in headless mode.\", 2)


func _process_transforms(transforms, _domain, _seed) -> void:
	var offset := offset_step
	if transforms.size() < 2:
		return

	# Disable the use of compute shader, if we cannot create a RenderingDevice
	if use_computeshader:
		var rd := RenderingServer.create_local_rendering_device()
		if rd == null:
			use_computeshader = false
		else:
			rd.free()
			rd = null

	if use_computeshader:
		for iteration in iterations:
			if interrupt_update:
				return
			var movedir: PackedVector3Array = compute_closest(transforms)
			for i in transforms.size():
				var dir = movedir[i]
				if restrict_height:
					dir.y = 0.0
				# move away from closest point
				transforms.list[i].origin += dir.normalized() * offset

			offset *= consecutive_step_multiplier

	else:
		# calculate the relax transforms on the cpu
		for iteration in iterations:
			for i in transforms.size():
				if interrupt_update:
					return
				var min_vector = Vector3.ONE * 99999.0
				var threshold := 99999.0
				var distance := 0.0
				var diff: Vector3

				# Find the closest point
				for j in transforms.size():
					if i == j:
						continue

					diff = transforms.list[i].origin - transforms.list[j].origin
					distance = diff.length_squared()

					if distance < threshold:
						min_vector = diff
						threshold = distance

				if restrict_height:
					min_vector.y = 0.0

				# move away from closest point
				transforms.list[i].origin += min_vector.normalized() * offset

			offset *= consecutive_step_multiplier


# compute the closest points to each other using a compute shader
# return a vector for each point that points away from the closest neighbour
func compute_closest(transforms) -> PackedVector3Array:
	var padded_num_vecs = ceil(float(transforms.size()) / 64.0) * 64
	var padded_num_floats = padded_num_vecs * 4
	var rd := RenderingServer.create_local_rendering_device()
	var shader_spirv: RDShaderSPIRV = shader_file.get_spirv()
	var shader := rd.shader_create_from_spirv(shader_spirv)
	# Prepare our data. We use vec4 floats in the shader, so we need 32 bit.
	var input := PackedFloat32Array()
	for i in transforms.size():
		input.append(transforms.list[i].origin.x)
		input.append(transforms.list[i].origin.y)
		input.append(transforms.list[i].origin.z)
		input.append(0) # needed to use vec4, necessary for byte alignment in the shader code
	# buffer size, number of vectors sent to the gpu
	input.resize(padded_num_floats) # indexing in the compute shader requires padding
	var input_bytes := input.to_byte_array()
	var output_bytes := input_bytes.duplicate()
	# Create a storage buffer that can hold our float values.
	var buffer_in := rd.storage_buffer_create(input_bytes.size(), input_bytes)
	var buffer_out := rd.storage_buffer_create(output_bytes.size(), output_bytes)

	# Create a uniform to assign the buffer to the rendering device
	var uniform_in := RDUniform.new()
	uniform_in.uniform_type = RenderingDevice.UNIFORM_TYPE_STORAGE_BUFFER
	uniform_in.binding = 0 # this needs to match the \"binding\" in our shader file
	uniform_in.add_id(buffer_in)
	# Create a uniform to assign the buffer to the rendering device
	var uniform_out := RDUniform.new()
	uniform_out.uniform_type = RenderingDevice.UNIFORM_TYPE_STORAGE_BUFFER
	uniform_out.binding = 1 # this needs to match the \"binding\" in our shader file
	uniform_out.add_id(buffer_out)
	# the last parameter (the 0) needs to match the \"set\" in our shader file
	var uniform_set := rd.uniform_set_create([uniform_in, uniform_out], shader, 0)

	# Create a compute pipeline
	var pipeline := rd.compute_pipeline_create(shader)
	var compute_list := rd.compute_list_begin()
	rd.compute_list_bind_compute_pipeline(compute_list, pipeline)
	rd.compute_list_bind_uniform_set(compute_list, uniform_set, 0)
	# each workgroup computes 64 vectors
#	print(\"Dispatching workgroups: \", padded_num_vecs/64)
	rd.compute_list_dispatch(compute_list, padded_num_vecs/64, 1, 1)
	rd.compute_list_end()
	# Submit to GPU and wait for sync
	rd.submit()
	rd.sync()
	# Read back the data from the buffer
	var result_bytes := rd.buffer_get_data(buffer_out)
	var result := result_bytes.to_float32_array()
	var retval = PackedVector3Array()
	for i in transforms.size():
		retval.append(Vector3(result[i*4], result[i*4+1], result[i*4+2]))

	# Free the allocated objects.
	# All resources must be freed after use to avoid memory leaks.
	if rd != null:
		rd.free_rid(pipeline)
		rd.free_rid(uniform_set)
		rd.free_rid(shader)
		rd.free_rid(buffer_in)
		rd.free_rid(buffer_out)
		rd.free()
		rd = null
	return retval
"

[sub_resource type="Resource" id="Resource_rv6hs"]
script = SubResource("GDScript_j3blm")
iterations = 3
offset_step = 0.2
consecutive_step_multiplier = 0.75
use_computeshader = true
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = true
reference_frame = 0

[sub_resource type="GDScript" id="GDScript_xdqla"]
script/source = "@tool
extends \"base_modifier.gd\"


signal projection_completed


const ProtonScatterPhysicsHelper := preload(\"res://addons/proton_scatter/src/common/physics_helper.gd\")


@export var ray_direction := Vector3.DOWN
@export var ray_length := 10.0
@export var ray_offset := 1.0
@export var remove_points_on_miss := true
@export var align_with_collision_normal := false
@export_range(0.0, 90.0) var max_slope = 90.0
@export_flags_3d_physics var collision_mask = 1
@export_flags_3d_physics var exclude_mask = 0


func _init() -> void:
	display_name = \"Project On Colliders\"
	category = \"Edit\"
	can_restrict_height = false
	global_reference_frame_available = true
	local_reference_frame_available = true
	individual_instances_reference_frame_available = true
	use_global_space_by_default()

	documentation.add_paragraph(
		\"Moves each transforms along the ray direction until they hit a collider.
		This is useful to avoid floating objects on uneven terrain for example.\")

	documentation.add_warning(
		\"This modifier only works when physics bodies are around. It will ignore
		simple MeshInstances nodes.\")

	var p := documentation.add_parameter(\"Ray direction\")
	p.set_type(\"Vector3\")
	p.set_description(
		\"In which direction we look for a collider. This default to the DOWN
		direction by default (look at the ground).\")
	p.add_warning(
		\"This is relative to the transform is local space is enabled, or aligned
		with the global axis if local space is disabled.\")

	p = documentation.add_parameter(\"Ray length\")
	p.set_type(\"float\")
	p.set_description(\"How far we look for other physics objects.\")
	p.set_cost(2)

	p = documentation.add_parameter(\"Ray offset\")
	p.set_type(\"Vector3\")
	p.set_description(
		\"Moves back the raycast origin point along the ray direction. This is
		useful if the initial transform is slightly below the ground, which would
		make the raycast miss the collider (since it would start inside).\")

	p = documentation.add_parameter(\"Remove points on miss\")
	p.set_type(\"bool\")
	p.set_description(
		\"When enabled, if the raycast didn't collide with anything, or collided
		with a surface above the max slope setting, the transform is removed
		from the list.
		This is useful to avoid floating objects that are too far from the rest
		of the scene's geometry.\")

	p = documentation.add_parameter(\"Align with collision normal\")
	p.set_type(\"bool\")
	p.set_description(
		\"Rotate the transform to align it with the collision normal in case
		the ray cast hit a collider.\")

	p = documentation.add_parameter(\"Max slope\")
	p.set_type(\"float\")
	p.set_description(
		\"Angle (in degrees) after which the hit is considered invalid.
		When a ray cast hit, the normal of the ray is compared against the
		normal of the hit. If you set the slope to 0°, the ray and the hit
		normal would have to be perfectly aligned to be valid. On the other
		hand, setting the maximum slope to 90° treats every collisions as
		valid regardless of their normals.\")

	p = documentation.add_parameter(\"Mask\")
	p.set_description(
		\"Only collide with colliders on these layers. Disabled layers will
		be ignored. It's useful to ignore players or npcs that might be on the
		scene when you're editing it.\")

	p = documentation.add_parameter(\"Exclude Mask\")
	p.set_description(
		\"Tests if the snapping would collide with the selected layers.
		If it collides, the point will be excluded from the list.\")


func _process_transforms(transforms, domain, _seed) -> void:
	if transforms.is_empty():
		return

	# Create all the physics ray queries
	var gt: Transform3D = domain.get_global_transform()
	var gt_inverse := gt.affine_inverse()
	var queries: Array[PhysicsRayQueryParameters3D] = []
	var exclude_queries: Array[PhysicsRayQueryParameters3D] = []

	for t in transforms.list:
		var start = gt * t.origin
		var end = start
		var dir = ray_direction.normalized()

		if is_using_individual_instances_space():
			dir = t.basis * dir

		elif is_using_local_space():
			dir = gt.basis * dir

		start -= ray_offset * dir
		end += ray_length * dir

		var ray_query := PhysicsRayQueryParameters3D.new()
		ray_query.from = start
		ray_query.to = end
		ray_query.collision_mask = collision_mask

		queries.push_back(ray_query)

		var exclude_query := PhysicsRayQueryParameters3D.new()
		exclude_query.from = start
		exclude_query.to = end
		exclude_query.collision_mask = exclude_mask
		exclude_queries.push_back(exclude_query)

	# Run the queries in the physics helper since we can't access the PhysicsServer
	# from outside the _physics_process while also being in a separate thread.
	var physics_helper: ProtonScatterPhysicsHelper = domain.get_root().get_physics_helper()

	var ray_hits := await physics_helper.execute(queries)

	if ray_hits.is_empty():
		return

	# Create queries from the hit points
	var index := -1
	for ray_hit in ray_hits:
		index += 1
		var hit : Dictionary = ray_hit
		if hit.is_empty():
			exclude_queries[index].collision_mask = 0 # this point is empty anyway, we dont care
			continue
		exclude_queries[index].to = hit.position # only cast up to hit point for correct ordering

	var exclude_hits : Array[Dictionary] = []
	if exclude_mask != 0: # Only cast the rays if it makes any sense
		exclude_hits = await physics_helper.execute(exclude_queries)

	# Apply the results
	index = 0
	var d: float
	var t: Transform3D
	var remapped_max_slope = remap(max_slope, 0.0, 90.0, 0.0, 1.0)
	var is_point_valid := false
	exclude_hits.reverse() # makes it possible to use pop_back which is much faster
	var new_transforms_array : Array[Transform3D] = []

	for hit in ray_hits:
		is_point_valid = true

		if hit.is_empty():
			is_point_valid = false
		else:
			d = abs(Vector3.UP.dot(hit.normal))
			is_point_valid = d >= (1.0 - remapped_max_slope)

		var exclude_hit = exclude_hits.pop_back()
		if exclude_hit != null:
			if not exclude_hit.is_empty():
				is_point_valid = false

		t = transforms.list[index]
		if is_point_valid:
			if align_with_collision_normal:
				t = _align_with(t, gt_inverse.basis * hit.normal)

			t.origin = gt_inverse * hit.position
			new_transforms_array.push_back(t)
		elif not remove_points_on_miss:
			new_transforms_array.push_back(t)

		index += 1

	# All done, store the transforms in the original array
	transforms.list.clear()
	transforms.list.append_array(new_transforms_array) # this avoids memory leak

	if transforms.is_empty():
		warning += \"\"\"Every points have been removed. Possible reasons include: \\n
		+ No collider is close enough to the shapes.
		+ Ray length is too short.
		+ Ray direction is incorrect.
		+ Collision mask is not set properly.
		+ Max slope is too low.
		\"\"\"


func _align_with(t: Transform3D, normal: Vector3) -> Transform3D:
	var n1 = t.basis.y.normalized()
	var n2 = normal.normalized()

	var cosa = n1.dot(n2)
	var alpha = acos(cosa)
	var axis = n1.cross(n2)

	if axis == Vector3.ZERO:
		return t

	return t.rotated(axis.normalized(), alpha)
"

[sub_resource type="Resource" id="Resource_h33oy"]
script = SubResource("GDScript_xdqla")
ray_direction = Vector3(0, -1, 0)
ray_length = 5.0
ray_offset = 5.0
remove_points_on_miss = false
align_with_collision_normal = false
max_slope = 90.0
collision_mask = 1
exclude_mask = 0
enabled = true
override_global_seed = false
custom_seed = 0
restrict_height = false
reference_frame = 0

[sub_resource type="Resource" id="Resource_aprwb"]
script = SubResource("GDScript_u21fa")
stack = [SubResource("Resource_670bh"), SubResource("Resource_o83yb"), SubResource("Resource_rv6hs"), SubResource("Resource_h33oy")]

[sub_resource type="GDScript" id="GDScript_j8c14"]
script/source = "@tool
extends Node3D


const ScatterUtil := preload('./common/scatter_util.gd')


@export_category(\"ScatterItem\")
@export var proportion := 100:
	set(val):
		proportion = val
		ScatterUtil.request_parent_to_rebuild(self)

@export_enum(\"From current scene:0\", \"From disk:1\") var source = 1:
	set(val):
		source = val
		property_list_changed.emit()

@export_group(\"Source options\", \"source_\")
@export var source_scale_multiplier := 1.0:
	set(val):
		source_scale_multiplier = val
		ScatterUtil.request_parent_to_rebuild(self)

@export var source_ignore_position := true:
	set(val):
		source_ignore_position = val
		ScatterUtil.request_parent_to_rebuild(self)

@export var source_ignore_rotation := true:
	set(val):
		source_ignore_rotation = val
		ScatterUtil.request_parent_to_rebuild(self)

@export var source_ignore_scale := true:
	set(val):
		source_ignore_scale = val
		ScatterUtil.request_parent_to_rebuild(self)

@export_group(\"Override options\", \"override_\")
@export var override_material: Material:
	set(val):
		override_material = val
		ScatterUtil.request_parent_to_rebuild(self)

@export var override_process_material: Material:
	set(val):
		override_process_material = val
		ScatterUtil.request_parent_to_rebuild(self) # TODO - No need for a full rebuild here

@export var override_cast_shadow: GeometryInstance3D.ShadowCastingSetting = GeometryInstance3D.SHADOW_CASTING_SETTING_ON:
	set(val):
		override_cast_shadow = val
		ScatterUtil.request_parent_to_rebuild(self) # TODO - Only change the multimesh flag instead

@export_group(\"Visibility\", \"visibility\")
@export_flags_3d_render var visibility_layers: int = 1
@export var visibility_range_begin : float = 0
@export var visibility_range_begin_margin : float = 0
@export var visibility_range_end : float = 0
@export var visibility_range_end_margin : float = 0
#TODO what is a nicer way to expose this?
@export_enum(\"Disabled:0\", \"Self:1\") var visibility_range_fade_mode = 0

@export_group(\"Level Of Detail\", \"lod_\")
@export var lod_generate := true:
	set(val):
		lod_generate = val
		ScatterUtil.request_parent_to_rebuild(self)
@export_range(0.0, 180.0) var lod_merge_angle := 25.0:
	set(val):
		lod_merge_angle = val
		ScatterUtil.request_parent_to_rebuild(self)
@export_range(0.0, 180.0) var lod_split_angle := 60.0:
	set(val):
		lod_split_angle = val
		ScatterUtil.request_parent_to_rebuild(self)

var path: String:
	set(val):
		path = val
		source_data_ready = false
		_target_scene = load(path) if source != 0 else null
		ScatterUtil.request_parent_to_rebuild(self)

var source_position: Vector3
var source_rotation: Vector3
var source_scale: Vector3
var source_data_ready := false

var _target_scene: PackedScene


func _get_property_list() -> Array:
	var list := []

	if source == 0:
		list.push_back({
			name = \"path\",
			type = TYPE_NODE_PATH,
		})
	else:
		list.push_back({
			name = \"path\",
			type = TYPE_STRING,
			hint = PROPERTY_HINT_FILE,
		})

	return list


func get_item() -> Node3D:
	if path.is_empty():
		return null

	var node: Node3D

	if source == 0 and has_node(path):
		node = get_node(path).duplicate() # Never expose the original node
	elif source == 1:
		node = _target_scene.instantiate()

	if node:
		_save_source_data(node)
		return node

	return null


# Takes a transform in input, scale it based on the local scale multiplier
# If the source transform is not ignored, also copy the source position, rotation and scale.
# Returns the processed transform
func process_transform(t: Transform3D) -> Transform3D:
	if not source_data_ready:
		_update_source_data()

	var origin = t.origin
	t.origin = Vector3.ZERO

	t = t.scaled(Vector3.ONE * source_scale_multiplier)

	if not source_ignore_scale:
		t = t.scaled(source_scale)

	if not source_ignore_rotation:
		t = t.rotated(t.basis.x.normalized(), source_rotation.x)
		t = t.rotated(t.basis.y.normalized(), source_rotation.y)
		t = t.rotated(t.basis.z.normalized(), source_rotation.z)

	t.origin = origin

	if not source_ignore_position:
		t.origin += source_position

	return t


func _save_source_data(node: Node3D) -> void:
	if not node:
		return

	source_position = node.position
	source_rotation = node.rotation
	source_scale = node.scale
	source_data_ready = true


func _update_source_data() -> void:
	var node = get_item()
	if node:
		node.queue_free()
"

[sub_resource type="GDScript" id="GDScript_ln03v"]
script/source = "@tool
extends Node3D


const ScatterUtil := preload('./common/scatter_util.gd')


@export_category(\"ScatterShape\")
@export var negative = false:
	set(val):
		negative = val
		update_gizmos()
		ScatterUtil.request_parent_to_rebuild(self)

@export var shape: ProtonScatterBaseShape:
	set(val):
		# Disconnect the previous shape if any
		if shape and shape.changed.is_connected(_on_shape_changed):
			shape.changed.disconnect(_on_shape_changed)

		shape = val
		if shape:
			shape.changed.connect(_on_shape_changed)

		update_gizmos()
		ScatterUtil.request_parent_to_rebuild(self)

var _ignore_transform_notification = false


func _ready() -> void:
	set_notify_transform(true)


func _notification(what):
	match what:
		NOTIFICATION_TRANSFORM_CHANGED:
			if _ignore_transform_notification:
				_ignore_transform_notification = false
				return
			ScatterUtil.request_parent_to_rebuild(self)

		NOTIFICATION_ENTER_WORLD:
			_ignore_transform_notification = true


func _set(property, _value):
	if not Engine.is_editor_hint():
		return false

	# Workaround to detect when the node was duplicated from the editor.
	if property == \"transform\":
		_on_node_duplicated.call_deferred()

	return false


func _on_shape_changed() -> void:
	update_gizmos()
	ScatterUtil.request_parent_to_rebuild(self)


func _on_node_duplicated() -> void:
	shape = shape.get_copy() # Enfore uniqueness on duplicate, could be an option
"

[sub_resource type="GDScript" id="GDScript_qq7gr"]
script/source = "@tool
class_name ProtonScatterSphereShape
extends ProtonScatterBaseShape


@export var radius := 1.0:
	set(val):
		radius = val
		_radius_squared = val * val
		emit_changed()

var _radius_squared := 0.0


func get_copy():
	var copy = ProtonScatterSphereShape.new()
	copy.radius = radius
	return copy


func is_point_inside(point: Vector3, global_transform: Transform3D) -> bool:
	var shape_center = global_transform * Vector3.ZERO
	return shape_center.distance_squared_to(point) < _radius_squared


func get_corners_global(gt: Transform3D) -> Array:
	var res := []

	var corners := [
		Vector3(-1, -1, -1),
		Vector3(-1, -1, 1),
		Vector3(1, -1, 1),
		Vector3(1, -1, -1),
		Vector3(-1, 1, -1),
		Vector3(-1, 1, 1),
		Vector3(1, 1, 1),
		Vector3(1, 1, -1),
	]

	for c in corners:
		c *= radius
		res.push_back(gt * c)

	return res



# Returns the circle matching the intersection between the scatter node XZ plane
# and the sphere. Returns an empty array if there's no intersection.
func get_closed_edges(shape_t: Transform3D) -> Array[PackedVector2Array]:
	var edge := PackedVector2Array()
	var plane := Plane(Vector3.UP, 0.0)

	var sphere_center := shape_t.origin
	var dist2plane = plane.distance_to(sphere_center)
	var radius_at_ground_level := sqrt(pow(radius, 2) - pow(dist2plane, 2))

	# No intersection with plane
	if radius_at_ground_level <= 0.0 or radius_at_ground_level > radius:
		return []

	var origin := Vector2(sphere_center.x, sphere_center.z)
	var steps: int = max(16, int(radius_at_ground_level * 12))
	var angle: float = TAU / steps

	for i in steps + 1:
		var theta = angle * i
		var point := origin + Vector2(cos(theta), sin(theta)) * radius_at_ground_level
		edge.push_back(point)

	return [edge]
"

[sub_resource type="Resource" id="Resource_g8bsm"]
script = SubResource("GDScript_qq7gr")
radius = 6.153

[sub_resource type="AtlasTexture" id="AtlasTexture_4f0ce"]
atlas = ExtResource("13_1oeb5")
region = Rect2(0, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_ceacm"]
atlas = ExtResource("13_1oeb5")
region = Rect2(32, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_tlrnv"]
atlas = ExtResource("13_1oeb5")
region = Rect2(64, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_4guus"]
atlas = ExtResource("13_1oeb5")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_wdy3w"]
atlas = ExtResource("13_1oeb5")
region = Rect2(128, 0, 32, 32)

[sub_resource type="SpriteFrames" id="SpriteFrames_km2hi"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_4f0ce")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_ceacm")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_tlrnv")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_4guus")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_wdy3w")
}],
"loop": true,
"name": &"default",
"speed": 3.0
}]

[node name="world" type="Node3D"]

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_h731i")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(-0.866025, -0.433013, 0.25, 0, 0.5, 0.866025, -0.5, 0.75, -0.433013, 0, 0, 0)
light_color = Color(0.955337, 0.826199, 0.948931, 1)
shadow_enabled = true

[node name="ground" type="Node3D" parent="."]
transform = Transform3D(3.26672, 0, 0, 0, 3.26672, 0, 0, 0, 3.26672, 0, 0, 0)

[node name="CSGBox3D" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 4.68649, -1.10869, -0.352173, 0)
use_collision = true
size = Vector3(1.47314, 0.232666, 1)
material = SubResource("StandardMaterial3D_tjqdc")

[node name="CSGBox3D8" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 4.68649, 10.7181, -0.352173, 0)
use_collision = true
size = Vector3(1.47314, 0.232666, 1)

[node name="CSGBox3D6" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 4.68649, -4.504, 1.06105, 1.37743)
use_collision = true
size = Vector3(0.0241699, 17.5692, 1.58783)

[node name="CSGBox3D9" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 4.68649, 8.6437, 0.0558255, -1.91706)
use_collision = true
size = Vector3(0.0241699, 5.23775, 0.0930023)

[node name="CSGBox3D10" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 4.68649, 8.6437, 0.0558255, -1.02638)
use_collision = true
size = Vector3(0.0241699, 5.23775, 0.0930023)

[node name="CSGBox3D11" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 4.68649, 8.6437, 0.0558255, -0.209873)
use_collision = true
size = Vector3(0.0241699, 5.23775, 0.0930023)

[node name="CSGBox3D12" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 4.68649, 8.6437, 0.0558255, -0.209873)
use_collision = true
size = Vector3(0.0241699, 5.23775, 0.0930023)

[node name="CSGBox3D13" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 4.68649, 26.0892, 2.01666, -2.75965)
use_collision = true
size = Vector3(0.0241699, 5.23775, 0.0930023)

[node name="CSGBox3D7" type="CSGBox3D" parent="ground"]
transform = Transform3D(-2.04853e-07, -4.94107e-16, -4.68649, -3.10928, 0.121984, 1.35911e-07, 3.5065, 0.108166, -1.53274e-07, -1.35469, 0.712785, 2.99306)
use_collision = true
size = Vector3(0.0241699, 27.2558, 1.83154)

[node name="CSGBox3D2" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -1.10297, -0.363285, -1.70244)
use_collision = true
size = Vector3(1.4707, 1.78333, 1)

[node name="CSGBox3D14" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -2.67282, -1.00202, -2.7806)
use_collision = true
size = Vector3(0.417114, 11.6765, 0.660645)

[node name="CSGBox3D15" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -0.990388, -3.53041, -1.54948)
use_collision = true
size = Vector3(1.39784, 20.0735, 2.45349)

[node name="CSGBox3D16" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.53958, 0.0405008, 0, -1.16421, 0.157923, 0, 0, 0, 1.37336, -5.12704, -1.92427, -0.909283)
use_collision = true
size = Vector3(0.411228, 3.32679, 1.52118)

[node name="CSGBox3D17" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -6.95762, -1.69668, -0.909283)
use_collision = true
size = Vector3(0.411228, 3.32679, 1.52118)

[node name="CSGBox3D18" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -6.33617, -1.43392, 1.29498)
use_collision = true
size = Vector3(0.14602, 3.32679, 0.524261)

[node name="CSGBox3D19" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -4.90464, -1.085, 1.46179)
use_collision = true
size = Vector3(0.14602, 3.32679, 0.524261)

[node name="CSGBox3D20" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -4.90464, -0.802399, 1.91008)
use_collision = true
size = Vector3(0.14602, 3.32679, 0.524261)

[node name="CSGBox3D21" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -4.90464, -0.530707, 2.18871)
use_collision = true
size = Vector3(0.14602, 3.32679, 0.524261)

[node name="CSGBox3D22" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -4.90464, -0.208433, 2.4376)
use_collision = true
size = Vector3(0.14602, 3.32679, 0.524261)

[node name="CSGBox3D23" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -4.90464, 0.121451, 2.79959)
use_collision = true
size = Vector3(0.14602, 3.32679, 0.524261)

[node name="CSGBox3D24" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -4.90464, 0.396859, 3.07822)
use_collision = true
size = Vector3(0.14602, 3.32679, 0.524261)

[node name="CSGBox3D25" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.163034, 0, 0, 0, 1.37336, -4.90464, 0.730758, 0.579233)
use_collision = true
size = Vector3(0.14602, 0.94318, 0.524261)

[node name="CSGBox3D3" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.487216, 0, 0, 0, 1.37336, -2.89473, -0.0607502, -2.29692)
use_collision = true
size = Vector3(0.71582, 10.3974, 0.134277)

[node name="CSGBox3D4" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.487216, 0, 0, 0, 1.37336, 0.909945, -0.0607502, -2.29692)
use_collision = true
size = Vector3(0.597168, 10.3974, 0.134277)

[node name="CSGBox3D5" type="CSGBox3D" parent="ground"]
transform = Transform3D(4.68649, 0, 0, 0, 0.487216, 0, 0, 0, 1.37336, -0.817088, 1.74121, -2.29692)
use_collision = true
size = Vector3(0.180542, 3.00047, 0.134277)

[node name="Player" parent="." instance=ExtResource("1_eeid0")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.10847, 0)

[node name="grass" parent="." instance=ExtResource("3_r00ms")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -5)

[node name="ProtonScatter" type="Node3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1.74761, -0.953589, 1.30234)
script = SubResource("GDScript_4h3ld")
render_mode = 1
keep_static_colliders = true
modifier_stack = SubResource("Resource_aprwb")
Performance/use_chunks = true
Performance/chunk_dimensions = Vector3(15, 15, 15)

[node name="ScatterItem" type="Node3D" parent="ProtonScatter"]
script = SubResource("GDScript_j8c14")
source = 0
path = "../../AnimatedSprite3D"

[node name="ScatterShape" type="Node3D" parent="ProtonScatter"]
transform = Transform3D(1, 0, -2.98023e-08, 0, 1, 0, 2.98023e-08, 0, 1, -4.52, 0, 0)
script = SubResource("GDScript_ln03v")
shape = SubResource("Resource_g8bsm")

[node name="AnimatedSprite3D" type="AnimatedSprite3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -6.39267)
offset = Vector2(0, 15)
pixel_size = 0.05
texture_filter = 0
sprite_frames = SubResource("SpriteFrames_km2hi")
autoplay = "default"
frame_progress = 0.302223
